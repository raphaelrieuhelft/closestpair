
(** {1 Project: the Closest Pair Problem} *)

(** {2 First Part: Specification of the problem, and the Brute-force algorithm}
*)

module Closest_Pair_Problem

predicate _TO_BE_COMPLETED
constant _VALUE_TO_BE_COMPLETED : 'a
constant _VARIANT_TO_BE_COMPLETED : int

use export int.Int
use export real.RealInfix
(** beware that operators on real numbers are suffixed with a dot:
    [+.], [-.], [*.], [<.], [>.], [<=.], [>=.] *)
use export real.Abs
(** absolute value [abs] from Why3's standard library *)
use import array.Array
use import ref.Ref

(** {3 Points in the plane in their distance} *)

type point = { x : real; y : real }

(** The distance function is left abstract and axiomatized.
    More axioms come later in specific cases for 1D and 2D *)
function dist (a b : point) : real
(** non-negativity *)
axiom dist_pos: forall a b. 0.0 <=. dist a b
(** symmetry *)
axiom dist_sym: forall a b. dist a b = dist b a

(** {3 Post-condition for all algorithms solving the problem} *)

type closest_pair_result = {
  delta : real;
  ghost first : int;
  ghost second : int;
}

(* QUESTION 1 *)

(** [distinct_index_in_range i j low high] states that [i] and [j] are
    distinct indices in the range [[low..high-1]] *)
predicate distinct_indices_in_range (i j low high : int) = 
  i >= low && j >= low && i<high && j < high && i <> j

(* QUESTION 2 *)

(** [closest_pair_post_for a low high r] states that [r] is a correct
    answer for the closest pair problem for sub-array
    [a[low..high-1]] *)
predicate closest_pair_post_for (a:array point) (low high:int)
                                (r:closest_pair_result) =
  distinct_indices_in_range r.first r.second low high &&
  dist a[r.first] a[r.second] = r.delta &&
  forall i j . distinct_indices_in_range i j low high -> dist a[i] a[j] >=. r.delta

(* QUESTION 3 *)

predicate closest_pair_post (a:array point) (r:closest_pair_result) =
  closest_pair_post_for a 0 a.length r

(** {3 Brute-force search} *)

(* QUESTION 4 *)

(** [brute_force_search_sub_array a low high] returns the minimal
    distance of points in the sub-array [a[low..high-1]]. The size of
    the sub-array must be at least 2. *)
let brute_force_search_sub_array (a:array point) (low high:int) :
     closest_pair_result
  requires { 0 <= low < low+1 < high <= a.length }
  ensures { closest_pair_post_for a low high result }
= let f = ref low in
  let s = ref (low+1) in
  let min = ref (dist a[low] a[low+1]) in
  for i = low to high - 2 do
    invariant {forall k l. distinct_indices_in_range k l low high /\ k < i
   -> dist a[k] a[l] >=. !min}
    invariant {dist a[!f] a[!s] = !min}
    invariant {distinct_indices_in_range !f !s low high}
    for j = i+1 to high - 1 do
      invariant {dist a[!f] a[!s] = !min}
      invariant {forall k l. distinct_indices_in_range k l low high /\ (k < i \/ (k = i /\ l < j)) 
   -> dist a[k] a[l] >=. !min}
      invariant { distinct_indices_in_range !f !s low high }
      let d = dist a[i] a[j] in
      if d <. !min then (f := i; s := j; min := d)
    done
  done;
  { delta = !min; first = !f; second = !s }

let brute_force_search (a:array point) : closest_pair_result
  requires { a.length >= 2 }
  ensures { closest_pair_post a result }
= brute_force_search_sub_array a 0 a.length

(** {3 Sorting, abstractly}

We need later to sort arrays, either along x-coordinate or y-coordinate.

This part is common to both the 1D and the 2D cases.

*)


(** for sorting we need to indicate with respect to which
    coordinate. This is stated by a 'projection' parameter of type
    [point -> real] *)
use import HighOrd

(** The two projection functions used in the remaining *)
function proj_x : point -> real = \p. p.x
function proj_y : point -> real = \p. p.y

(** [sorted proj a] states that the array [a] is sorted in increasing
    order with respect to the projection function [proj] *)
predicate sorted (proj : point -> real) (a:array point) =
  forall i j. 0 <= i <= j < a.length -> proj a[i] <=. proj a[j]

(** ghost result of a sorting algorithm is a pair of mapping [d] and
    [r] such that [d] o [r] = [r] o [d], thus forming a bijection. *)
type permutations = {
   ghost direct : int -> int;
   ghost reciprocal : int -> int;
}

(** [is_permute a b p] expresses that [b] is obtained by a permutation
    of [a], where [p] indicates for which permutation of the indices *)
predicate is_permute (a b:array 'a) (p : permutations) =
  a.length = b.length &&
  forall i. 0 <= i < a.length ->
    0 <= p.direct i < a.length /\ 0 <= p.reciprocal i < a.length /\
    p.direct (p.reciprocal i) = i /\ p.reciprocal (p.direct i) = i /\
    b[i] = a[p.direct i] /\ a[i] = b[p.reciprocal i]

(** [sort a] is assumed to sort the array [a] in increasing order.
    It is known that it can be implemented with a worst-case
    time complexity of O(n log n) *)
val sort (proj:point -> real) (a:array point) : permutations
  writes { a }
  ensures { sorted proj a }
  ensures { is_permute (old a) a result }

end






(** {2 Solutions of the closest pair problem in dimension 1} *)

module Dimension1

clone import Closest_Pair_Problem
use import array.Array
use import ref.Ref
use int.ComputerDivision


(** {3 Axiomatization of distance for the 1D case} *)
axiom dist_in_1d: forall a b. dist a b = abs (a.x -. b.x)

(** [points_on_x_axis a] states that all points in [a] lie on the
    x-axis. Notice, however, that this hypothesis is in fact not
    needed in the remaining. *)
predicate points_on_x_axis (a:array point) =
  forall i. 0 <= i < a.length -> a[i].y = 0.0


(** {3 Algorithms assuming a sorted array as input} *)



(* QUESTION 5 *)

(** [linear_search a] returns the solution to the closest pair problem
    for the set of points [a], assuming that [a] is sorted. Worst-case
    time complexity is O(n) *)

let lemma middle_are_closer (a:array point) (i j k l:int) :unit
  requires { sorted proj_x a }
  requires { a.length >= 2 }
  requires { 0 <= i <= j < k <= l < a.length }
  ensures { dist a[i] a[l] >=. dist a[j] a[k] }
=()

let linear_search (a:array point) : closest_pair_result
  requires { a.length >=2 }
  requires { sorted proj_x a }
  ensures { closest_pair_post a result }
= let f = ref 0 in
  let min = ref (dist a[0] a[1]) in
  for i = 1 to a.length - 2 do
    invariant { distinct_indices_in_range !f (!f+1) 0 a.length }
    invariant { dist a[!f] a[!f+1] = !min }
    invariant { forall k l. distinct_indices_in_range k l 0 (i+1) /\ k < l -> dist a[k] a[l] >=.  dist a[k] a[k+1] >=. !min }
    let d = dist a[i] a[i+1] in
      if d <. !min then (min := d; f := i)
  done;
  { delta = !min ; first = !f; second = !f + 1 }

(* QUESTION 6 *)

(** [divide_and_conquer a] returns the solution to the closest pair problem
    for the set of points [a], assuming that [a] is sorted. Worst-case
    time complexity is O(n) *)
let rec divide_and_conquer (a:array point) (low high:int) : closest_pair_result
  requires { sorted proj_x a }
  requires { 0 <= low < high -1 < high <= a.length}
  variant { high - low }
  ensures { closest_pair_post_for a low high result }
= let len = high - low in
  if len <= 3 then brute_force_search_sub_array a low high else
  let middle = low + ComputerDivision.div len 2 in
  let r1 = divide_and_conquer a low middle in
  let r2 = divide_and_conquer a middle high in
  let r = if r1.delta <. r2.delta then r1 else r2 in
  let d = dist a[middle - 1] a[middle] in
  assert { forall i j . distinct_indices_in_range i j low high /\ i < j -> 
  	 distinct_indices_in_range i j low middle \/
	 distinct_indices_in_range i j middle high \/
	 i <= middle-1 < middle <= j
	 };
  assert { forall i j . distinct_indices_in_range i j low middle -> dist a[i] a[j] >=. r.delta };
  assert { forall i j . distinct_indices_in_range i j middle high -> dist a[i] a[j] >=. r.delta };
  assert { forall i j . distinct_indices_in_range i j low high /\ i <= middle-1 < middle <= j  -> 
  	 dist a[i] a[j] >=. dist a[middle-1] a[middle] >=. d };
  if d <. r.delta then
     (assert { forall i j . distinct_indices_in_range i j low high -> dist a[i] a[j] >=. d };
     { delta = d ; first = middle - 1 ; second = middle })
  else (
        assert { forall i j . distinct_indices_in_range i j low high -> dist a[i] a[j] >=. r.delta};
       r)



(* QUESTION 7 *)


(** [full_divide_and_conquer a] returns the solution to the closest pair
    problem for the set of points [a]. Assuming that sorting is done
    in O(n log n), worst-case time complexity is O(n log n) too. *)
let full_divide_and_conquer (a:array point) : closest_pair_result
  requires { a.length >= 2}
  ensures { closest_pair_post a result }
= let b = Array.copy a in
  let p = sort proj_x b in
  let r = divide_and_conquer b 0 a.length in
  assert { forall i j . distinct_indices_in_range i j 0 a.length -> dist a[i] a[j] = dist b[p.reciprocal i] b[p.reciprocal j] >=. r.delta };
  { delta = r.delta ; first = p.direct r.first ; second = p.direct r.second }
end



(** {2 Second Part: The Closest Pair problem in Dimension 2} *)



module Dimension2

clone import Closest_Pair_Problem
use import int.ComputerDivision
use import array.Array
use import ref.Ref

(** {3 Axiomatization of distance for the 2D case} *)

(** Inequality w.r.t. projections *)
axiom dist_proj_x: forall a b. abs (a.x -. b.x) <=. dist a b
axiom dist_proj_y: forall a b. abs (a.y -. b.y) <=. dist a b

(** {3 Divide-and-Conquer Approach} *)

(* QUESTION 8 *)

exception Break

(** [search_strip a delta] searchs for the minimal distance of points
     in the array [a], assuming it is less than [delta]. It is assumed
     that all the points lie in some "vertical strip", that is there
     exists a value [mu] such that the x coordinate of points belong
     to the [mu - delta, mu + delta].  If the minimal distance is not
     less than [delta], this function just returns [delta]. *)
let search_strip (a:array point) (delta:real) : closest_pair_result
  requires { exists mu. forall i. 0 <= i < a.length -> mu -. delta <. a[i].x <. mu +. delta}
  ensures { result.delta <=. delta }
  ensures { result.delta <. delta -> distinct_indices_in_range result.first result.second 0 a.length }
  ensures { result.delta <. delta -> closest_pair_post a result }
  ensures { result.delta = delta -> forall i j. distinct_indices_in_range i j 0 a.length -> dist a[i] a[j] >=. delta }
= if a.length < 2 then
    (* dummy values for first and second *)
    { delta = delta ; first = 0; second = 0 }
  else
  let b = Array.copy a in
  let p = sort proj_y b in
  let f = ref 0 in
  let s = ref 0 in
  let m = ref delta in
  for i = 0 to b.length - 2 do
    invariant { !m <. delta -> dist b[!f] b[!s] = !m }
    invariant { forall k l . distinct_indices_in_range k l 0 a.length /\ k < i -> dist b[k] b[l] >=. !m }
    invariant { !m <. delta -> distinct_indices_in_range !f !s 0 a.length }
    try
      for j = i+1 to b.length - 1 do
        invariant { !m <. delta -> dist b[!f] b[!s] = !m }
        invariant { forall k l . distinct_indices_in_range k l 0 a.length /\ (k < i \/ (k = i /\ (l < j)))
		  -> dist b[k] b[l] >=. !m }
        invariant { !m <. delta -> distinct_indices_in_range !f !s 0 a.length }
        if b[j].y >=. b[i].y +. !m then
          begin
            assert { dist b[i] b[j] >=. !m };
            raise Break;
          end;
        let d = dist b[i] b[j] in
        if d <. !m then (m := d; f := i; s := j);
     done
    with Break -> ()
    end
  done; 
  if !m <. delta then
     begin
     assert { forall i j. distinct_indices_in_range i j 0 a.length ->  dist a[i] a[j] = dist b[p.reciprocal i] b[p.reciprocal j] >=. !m };
     let f' = p.direct !f in let s' = p.direct !s in 
     assert { distinct_indices_in_range f' s' 0 a.length };
     assert { dist a[f'] a[s'] = dist b[!f] b[!s] = !m };
     { delta = !m ; first = f'; second = s' }
     end
  else begin
     assert { forall k l. distinct_indices_in_range k l 0 a.length -> dist a[k] a[l] = dist b[p.reciprocal k] b[p.reciprocal l] >=. delta };
     { delta = delta ; first = 0; second = 0 }
     end


(* QUESTION 9 *)

(** [left_border a low middle mu delta] returns an index [k]
    such that all points in [a[low..k-1]] have x-coordinate less or
    equal [mu - delta], whereas points in [a[k..middle-1]] have
    x-coordinate larger than [mu - delta]. It
    assumes [a] sorted in x. *)
let left_border (a:array point) (low middle : int)
              (mu delta : real) : int
  requires { sorted proj_x a }
  requires { 0 <= low <  middle <  a.length }
  ensures { low <= result <= middle }
  ensures { forall i. result <= i < middle -> mu -. delta <. a[i].x }
  ensures { forall i. low <= i < result -> a[i].x <=. mu -. delta }
= let l = ref middle in
  while !l >= low+1 && a[!l-1].x >. mu -. delta do
    variant { !l }
    invariant { low <= !l <= middle }
    invariant { !l < middle -> a[!l].x >. mu -. delta }
    l := !l - 1
  done;
  !l

(** [right_border a middle high mu delta] returns an index [k] such
    that all points in [a[middle..k-1]] have x-coordinate less than
    [mu+delta] whereas points in [a[k..high-1]] have x-coordinate
    greater or equal [mu+delta]. It assumes [a] sorted in x. *)
let right_border (a:array point) (middle high : int)
              (mu delta : real) : int
  requires { sorted proj_x a }
  requires { 0 < middle < high <= a.length }
  ensures { middle <= result <= high }
  ensures { forall i. middle <= i < result -> mu +. delta >. a[i].x }
  ensures { forall i. result <= i < high -> mu +. delta <=. a[i].x }
= let r = ref high in
  while !r >= middle + 1 && a[!r-1].x >=. mu +. delta do
    variant { !r }
    invariant { middle <= !r <= high }
    invariant { !r < high -> a[!r].x >=. mu +. delta }
    r := !r-1
  done;
  !r

(** {3 Divide and Conquer approach} *)

(* QUESTION 10 *)

(** [divide_and_conquer a low high] returns the solution to the
    closest pair problem for the sub-array [a[low..high-1]]. It
    assumes [a] of length at least 2 and sorted in increasing order
    with respect to the x-coordinate. *)

let rec divide_and_conquer (a:array point) (low high:int) : closest_pair_result
  requires { high - low  >= 2 }
  requires { sorted proj_x a }
  requires { 0 <= low < high <= a.length }
  variant { high - low }
  ensures { closest_pair_post_for a low high result }
= let len = high - low in
  if len <= 7 then brute_force_search_sub_array a low high else
    begin
      let middle = low + div len 2 in
      let r1 = divide_and_conquer a low middle in
      let r2 = divide_and_conquer a middle high in
      let r = if r1.delta <. r2.delta then r1 else r2 in
      let d = r.delta in
      let mu = (a[middle - 1].x +. a[middle].x) /. 2.0 in
      let left = left_border a low middle mu d in
      let right = right_border a middle high mu d in
      assert { 0 <= low <= left <= middle <= right <= high <= a.length };
      assert { forall i. middle <= i < right -> a[middle].x <=. a[i].x };
      assert { forall i. left <= i < middle -> a[i].x <=. a[middle].x };
      assert { forall i. left <= i < middle -> a[i].x >. mu -. d };
      assert { forall i. middle <= i < right -> a[i].x <. mu +. d };
      assert { forall i. left <= i < right -> mu -. d <. a[i].x <. mu +. d };
      let temp = Array.sub a left (right - left) in
      (* temp is the sub-array a[left..right-1] *) 
      assert { forall i. 0 <= i < temp.length -> temp[i] = a[left + i] };
      assert { forall i. 0 <= i < temp.length -> left <= left + i < right };
      assert { forall i. 0 <= i < temp.length -> mu -. d <. temp[i].x <. mu +. d };
      assert { forall i j . distinct_indices_in_range i j low high /\ i < j -> 
  	      distinct_indices_in_range i j low middle \/
	      distinct_indices_in_range i j middle high \/
	      distinct_indices_in_range i j left right \/
	      i < left <= middle <= j \/
	      i <= middle-1 < right <= j
	      };
      let res = search_strip temp d in
      assert { forall k l. 0 <= k <= l < a.length -> proj_x a[k] <=. proj_x a[l] };
      assert { forall j. left <= middle <= j < high -> a[middle].x <=. a[j].x }; 
      assert { forall i j. distinct_indices_in_range i j low high /\ i < left <= middle <= j ->  a[middle].x <=. a[j].x };
      assert { a[middle].x >=. mu };
      assert { forall i j. distinct_indices_in_range i j low high /\ i < left <= middle <= j -> a[i].x <=. mu -. d };
      assert { forall i j. distinct_indices_in_range i j low high /\ i < left <= middle <= j -> dist a[i] a[j] >=. d  };
      assert { forall i j. distinct_indices_in_range i j low high /\ i < middle /\ right <= j -> a[i].x <=. mu /\ a[j].x >=. mu +. d };
      assert { forall i j. distinct_indices_in_range i j low high /\ i < middle /\ right <= j -> dist a[i] a[j] >=. d };  
      if res.delta <. d then
        begin
	  assert { forall i j. distinct_indices_in_range i j 0 temp.length -> dist temp[i] temp[j] >=. res.delta };
	  assert { forall i j. distinct_indices_in_range i j left right -> dist a[i] a[j] = dist temp[i-left] temp [j-left]  >=. res.delta};
	  assert { forall i j. distinct_indices_in_range i j low high /\ i < left <= middle <= j -> dist a[i] a[j] >=. d >=. res.delta };
	  assert { forall i j. distinct_indices_in_range i j low high /\ i <= middle-1 < right <= j -> dist a[i] a[j] >=. d >=. res.delta };
	  assert { forall i j. distinct_indices_in_range i j low high -> dist a[i] a[j] >=. res.delta };
	  { res with first = left + res.first; second = left + res.second }
        end
      else 
        begin
	  assert { forall i j. distinct_indices_in_range i j left right -> dist a[i] a[j] = dist temp[i-left] temp[j-left] >=. d };
	  assert { forall i j. distinct_indices_in_range i j low high -> dist a[i] a[j] >=. res.delta };
      	  r
        end
    end


(* QUESTION 11 *)

(** [main_algorithm a] returns the solution to the
    closest pair problem for the points stored in array [a]. It
    assumes [a] of length at least 2. *)
let main_algorithm (a:array point) : closest_pair_result
  requires { a.length >= 2 }
  ensures { closest_pair_post a result }
= let b = Array.copy a in
  let p = sort proj_x b in
  let r = divide_and_conquer b 0 b.length in 
  assert { closest_pair_post b r } ;
  assert { forall i j . distinct_indices_in_range i j 0 a.length -> dist a[i] a[j] = dist b[p.reciprocal i] b[p.reciprocal j] >=. r.delta };
  { delta = r.delta ; first = p.direct r.first ; second = p.direct r.second }


(** {2 Complexity Analysis}

We need more geometric properties of the distance, we state them as
axioms.

*)

(** invariance by translation *)
axiom dist_inv_by_translation :
  forall x1 y1 x2 y2 dx dy : real.
   dist {x=x1-.dx;y=y1-.dy} {x=x2-.dx;y=y2-.dy} =
   dist {x=x1;y=y1} {x=x2;y=y2}

(** invariance by symmetry *)
axiom dist_inv_by_symmetry :
  forall x1 y1 x2 y2 dx dy : real.
   dist {x=dx-.x1;y=y1-.dy} {x=dx-.x2;y=y2-.dy} =
   dist {x=x1;y=y1} {x=x2;y=y2}

axiom dist_smaller_than_manhattan_dist:
  forall a b. dist a b <=. abs (a.x -. b.x) +. abs (a.y -. b.y)

predicate in_square (p:point) (delta:real) =
  0.0 <=. p.x <. delta /\ 0.0 <=. p.y <=. delta

(** [too_many_points_in_square] is a geometric property stated as a
    ghost function instead of an axiom, so as to be invoked by hand on
    specific instances when needed. It states that it is a
    contradiction if there are 4 points in the square [[0,delta]] x
    [[0,delta]] (x=[delta] excluded) whose pairwise distances are less
    or equal [delta].
    This geometric property is automatically proved by CVC4 1.4. *)
let ghost too_many_points_in_square (delta:real) (a b c d : point) : unit
  requires { in_square a delta }
  requires { in_square b delta }
  requires { in_square c delta }
  requires { in_square d delta }
  requires { delta <=. dist a b }
  requires { delta <=. dist a c }
  requires { delta <=. dist a d }
  requires { delta <=. dist b c }
  requires { delta <=. dist b d }
  requires { delta <=. dist c d }
  ensures { false }
= ()

(* QUESTION 12 *)

(** [pigeon_hole side k] take a boolean array [side] of size at least
    7, and an index [k] such that [[k,k+6]] is a valid sub-range of
    indices of [side]. It returns a 5-uple [(i1,i2,i3,i4,r)] such that
    [i1] to [i4] are four distinct indices in the range [k,k+6], and
    [r] is the 'common side' of them. *)

let ghost check_order_2 (a:array int) (bound i j:int)
  requires { 0 <= i < j < bound <= a.length }
  requires { forall u v. distinct_indices_in_range u v 0 bound /\ u < v -> a[u] < a[v] }
  ensures { a[i] < a[j] }
= assert { distinct_indices_in_range i j 0 bound }; ()

let ghost check_order_4 (a:array int) (bound i j k l:int)
  requires { 0 <= i < j < k < l < bound <= a.length }
  requires { forall u v. distinct_indices_in_range u v 0 bound /\ u < v -> a[u] < a[v] }
  ensures { a[i] < a[j] < a[k] < a[l] }
= check_order_2 a bound i j; check_order_2 a bound j k; check_order_2 a bound k l; ()


let ghost pigeon_hole (side:array bool) (k:int) : (int,int,int,int,bool)
  requires { 0 <= k }
  requires { k + 6 < side.length }
  ensures  { match result with (i1,i2,i3,i4,s) ->
              k <= i1 < i2 < i3 < i4 <= k + 6 &&
              side[i1] = side[i2] = side[i3] = side[i4] = s
            end }
= let left = Array.make 7 0 in
  let right = Array.make 7 0 in
  let nl = ref 0 in
  let nr = ref 0 in
  for i = k to k+6 do
    invariant { 0 <= !nl <= 7 }
    invariant { 0 <= !nr <= 7 }
    invariant { k + !nl + !nr = i }
    invariant { forall j. 0 <= j < !nl -> side[left[j]] }
    invariant { forall j. 0 <= j < !nr -> not side[right[j]] }
    invariant { forall u v. distinct_indices_in_range u v 0 !nl /\ u < v -> left[u] < left[v] }
    invariant { forall u v. distinct_indices_in_range u v 0 !nr /\ u < v -> right[u] < right[v] }
    invariant { forall j. 0 <= j < !nl -> k <= left[j] < i }
    invariant { forall j. 0 <= j < !nr -> k <= right[j] < i }
    if side[i] then begin
		    assert { forall u v. distinct_indices_in_range u v 0 (!nl + 1) /\ u < v -> distinct_indices_in_range u v 0 !nl \/ v = !nl };
		    left[!nl] <- i; 
		    nl := !nl + 1
		    end
               else begin
		    assert { forall u v. distinct_indices_in_range u v 0 (!nr + 1) /\ u < v -> distinct_indices_in_range u v 0 !nr \/ v = !nr };
	       	    right[!nr] <- i; 
		    nr := !nr + 1
		    end
  done;
  assert { !nl + !nr = 7 };
  if !nl > !nr then begin
     	       	    assert { !nl >= 4 };
		    assert { forall u v. distinct_indices_in_range u v 0 4 /\ u < v -> distinct_indices_in_range u v 0 !nl /\ u < v };
		    assert { forall u v. distinct_indices_in_range u v 0 4 /\ u < v -> left[u] < left[v] };
		    check_order_4 left !nl 0 1 2 3;
     	       	    (left[0],left[1],left[2],left[3],True)
		    end
               else begin
	       	    assert { !nr >= 4 };
		    assert { forall u v. distinct_indices_in_range u v 0 4 /\ u < v -> distinct_indices_in_range u v 0 !nr /\ u < v };
		    assert { forall u v. distinct_indices_in_range u v 0 4 /\ u < v -> right[u] < right[v] };
		    check_order_4 right !nr 0 1 2 3;
	       	    (right[0],right[1],right[2],right[3],False)
		    end

(* QUESTION 13 *)

(** [too_many_points_in_rectangle a mu delta k side] is a ghost function that
    derives a contradiction assuming that all the 7 points [a[k]] to
    [a[k+6]] lie in a rectangle of dimensions [delta x 2delta], x-centered on
    [mu]. [side] is an array of same length as [a] such that
    [side[i]] is True when [a[i]] is on the right of [mu] and
    False if it is on the left. It is assumed that when two points are
    on the same side, then their distance is at least [delta].  *)


let ghost too_many_points_in_rectangle (a:array point) (mu delta:real)
                          (k:int) (side:array bool)
  requires { 0.0 <=. delta }
  requires { 0 <= k }
  requires { k + 6 < a.length }
  requires { forall i. k+1 <= i <= k + 6 ->
               a[k].y <=. a[i].y <. a[k].y +. delta }
  requires { forall i. k <= i <= k + 6 ->
               mu -. delta <. a[i].x <. mu +. delta }
  requires { side.length = a.length }
  requires { forall i. 0 <= i < a.length ->
     if side[i] then a[i].x >=. mu else a[i].x <=. mu }
  requires { forall i j. distinct_indices_in_range i j 0 a.length ->
     side[i] = side[j] -> delta <=. dist a[i] a[j] }
  ensures { false }
= let base = a[k].y in
  let (i1,i2,i3,i4,s) = pigeon_hole side k in
  (* call too_many_points_in_square with appropriate symmetry and translation *)
  if s 
  then
     ( too_many_points_in_square delta { x = a[i1].x -. mu; y = a[i1].y -. base } { x = a[i2].x -. mu; y = a[i2].y -. base } { x = a[i3].x -. mu; y = a[i3].y -. base } { x = a[i4].x -. mu; y = a[i4].y -. base } )
  else (
     let ts1 = { x = mu -. a[i1].x ; y = a[i1].y -. base } in
     let ts2 = { x = mu -. a[i2].x ; y = a[i2].y -. base } in
     let ts3 = { x = mu -. a[i3].x ; y = a[i3].y -. base } in
     let ts4 = { x = mu -. a[i4].x ; y = a[i4].y -. base } in
     too_many_points_in_square delta ts1 ts2 ts3 ts4 )


(* QUESTION 14 *)

(** [search_strip_complexity] is a variant of [search_strip] with
    extra ghost parameters. It is proved, thanks to the loop invariant
    [j <= i + 6], that the number of iterations of the inner loop is
    bounded, from which we derive by a meta-argument that its
    worst-case time complexity is linear in the length of [a]. *)
let search_strip_complexity (a:array point) (delta : real)
    (ghost mu : real) (ghost side:array bool)
    : closest_pair_result
  requires { side.length = a.length }
  requires { forall i. 0 <= i < a.length ->
     if side[i] then a[i].x >=. mu else a[i].x <=. mu }
  requires { forall i j. distinct_indices_in_range i j 0 a.length ->
     side[i] = side[j] -> delta <=. dist a[i] a[j] }
  requires { forall i. 0 <= i < a.length -> mu -. delta <. a[i].x <. mu +. delta}
  ensures { result.delta <=. delta }
  ensures { result.delta <. delta -> distinct_indices_in_range result.first result.second 0 a.length }
  ensures { result.delta <. delta -> closest_pair_post a result }
  ensures { result.delta = delta -> forall i j. distinct_indices_in_range i j 0 a.length -> dist a[i] a[j] >=. delta }
= if a.length < 2 then
    (* dummy values for first and second *)
    { delta = delta ; first = 0; second = 0 }
  else
  let b = Array.copy a in
  let p = sort proj_y b in
  let bside = Array.copy side in
  for i = 0 to b.length-1 do
    invariant { forall j. 0 <= j < i -> if bside[j] then b[j].x >=. mu else b[j].x <=. mu }
    invariant { forall j. 0 <= j < i -> bside[j] = side[p.direct j] }
    bside[i] <- side [p.direct i];
    assert { b[i] = a[p.direct i] /\ if bside[i] then b[i].x >=. mu else b[i].x <=. mu }
  done;
  let f = ref 0 in
  let s = ref 0 in
  let m = ref delta in
  for i = 0 to b.length - 2 do
    invariant { distinct_indices_in_range !f !s 0 a.length -> dist b[!f] b[!s] = !m }
    invariant { forall k l . distinct_indices_in_range k l 0 a.length /\ k < i /\ k < l -> dist b[k] b[l] >=. !m }
    invariant { !m <. delta -> distinct_indices_in_range !f !s 0 a.length }
    invariant { !m <=. delta }
    try
      for j = i+1 to b.length - 1 do
        invariant { distinct_indices_in_range !f !s 0 a.length -> dist b[!f] b[!s] = !m }
        invariant { forall k l . distinct_indices_in_range k l 0 a.length /\ (k < i \/ (k = i /\ (l < j))) /\ k < l 
		  -> dist b[k] b[l] >=. !m }
        invariant { !m <. delta -> distinct_indices_in_range !f !s 0 a.length }
	invariant { !m <=. delta }
	invariant { j <= i + 6 }
	invariant { forall k. i+1 <= k < j -> b[i].y <=. b[k].y <. b[i].y +. delta }
        if b[j].y >=. b[i].y +. !m then
          begin
            assert { dist b[i] b[j] >=. !m };
            raise Break;
          end;
	assert { b[i].y <=. b[j].y <. b[i].y +. !m <=. b[i].y +. delta };
	assert { forall k. 0 <= k < a.length -> mu -. delta <. a[k].x <. mu +. delta };
	assert { forall k. 0 <= k < b.length -> b[k] = a[p.direct k] };
	assert { forall k. 0 <= k < b.length -> 0 <= p.direct k < a.length };
	assert { forall k. 0 <= k < b.length -> mu -. delta <. b[k].x <. mu +. delta };
	assert { forall i j. distinct_indices_in_range i j 0 b.length -> dist b[i] b[j] = dist a[p.direct i] a[p.direct j] };
	assert { forall i j. distinct_indices_in_range i j 0 b.length -> bside[i] = bside[j] -> side[p.direct i] = bside[i] = bside[j] = side[p.direct j] };
	assert { forall i j. distinct_indices_in_range i j 0 b.length -> bside[i] = bside[j] -> delta <=. dist  a[p.direct i] a[p.direct j] };
	assert { forall i j. distinct_indices_in_range i j 0 b.length -> bside[i] = bside[j] -> delta <=. dist b[i] b[j] };
        if j = i + 6 then too_many_points_in_rectangle b mu delta i bside;
        let d = dist b[i] b[j] in
        if d <. !m then (m := d; f := i; s := j);
     done
    with Break -> ()
    end
  done; 
  if !m <. delta then
     begin
     assert { closest_pair_post b { delta = !m; first = !f; second = !s } }; 
     assert { forall i j. distinct_indices_in_range i j 0 a.length ->  dist a[i] a[j] = dist b[p.reciprocal i] b[p.reciprocal j] >=. !m };
     let f' = p.direct !f in let s' = p.direct !s in 
     { delta = !m ; first = f'; second = s' }
     end
  else begin
     assert { forall k l. distinct_indices_in_range k l 0 a.length /\ k < b.length -1 /\ k < l -> dist b[k] b[l] >=. delta };
     assert { forall k l. distinct_indices_in_range k l 0 a.length /\ k < l -> k < b.length - 1 };
     assert { forall k l. distinct_indices_in_range k l 0 a.length -> dist a[k] a[l] = dist b[p.reciprocal k] b[p.reciprocal l] >=. delta };
     { delta = delta ; first = 0; second = 0 }
     end


(* take code from search_strip and insert :

        invariant { j <= i + 6 }
        if b[j].y >=. b[i].y +. !m then
          begin
            ...
            raise Break;
          end;
        if j = i + 6 then too_many_points_in_rectangle ...;

*)

end

